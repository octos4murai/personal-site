<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Implementing a Date Range Parser | Al Idian</title>

    <meta name="description" content="A personal site about software development">

    <link rel="preconnect" href="https://fonts.gstatic.com"> 
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&amp;family=Merriweather&amp;display=swap">

    <link rel="stylesheet" href="/css/syntax-highlight.css">
    <link rel="stylesheet" href="/css/style.css">

    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
</head>
<body>
    <header>
        <h3 id="site-title" class="no-margin no-padding"><a href="/">Al Idian</a></h3>
    </header>

    <main>
        
<h1 id="post-title">Implementing a Date Range Parser</h1>
<p id="post-date" class="gray-text">2016.11.05</p>

<p>Recently, I was tasked with writing an application in C# to scrape a web page on a schedule. Unfortunately, the dates on the web page followed a variety of formats, and there was no easy way to definitively predict which format was going to be used.</p>
<p>To solve this dilemma, I gathered the different formats used in the web page and wrote a component <a href="https://gist.github.com/octos4murai/2317bdd4b977744ebbfd314bf1cb9830">DateRangeParser.cs</a> to abstract away this date format issue.</p>
<p>DateRangeParser accepts the following formats and returns a start date and end date, as shown below:</p>
<table>
<thead>
<tr>
<th>String to Parse</th>
<th>Returned Start Date</th>
<th>Returned End Date</th>
</tr>
</thead>
<tbody>
<tr>
<td>19 November - 31 December 2016</td>
<td>2016-11-19</td>
<td>2016-12-31</td>
</tr>
<tr>
<td>07 December 2016</td>
<td>2016-12-07</td>
<td>2016-12-07</td>
</tr>
<tr>
<td>12 and 13 December 2016</td>
<td>2016-12-12</td>
<td>2016-12-13</td>
</tr>
<tr>
<td>01 - 31 January 2017</td>
<td>2017-01-01</td>
<td>2017-01-31</td>
</tr>
</tbody>
</table>
<h3>Sample usage</h3>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">string</span></span> dateRangeString <span class="token operator">=</span> <span class="token string">"19 November - 31 December 2016"</span><span class="token punctuation">;</span><br><span class="token class-name">ScheduledOutagesDateRangeParser</span> dateRangeParser<span class="token punctuation">;</span><br><br><span class="token comment">// parsedDates is a list of two dates: start date and end date</span><br><span class="token class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span> parsedDates <span class="token operator">=</span> dateRangeParser<span class="token punctuation">.</span><span class="token function">ParseDateRangeString</span><span class="token punctuation">(</span>dateRangeString<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> parsedDates<span class="token punctuation">;</span></code></pre>
<h3>Implementation</h3>
<p>Inspired by machine learning data processing techniques, DateRangeParser begins by creating a word bank and a proximity table.</p>
<p>A word bank is a 1 x n matrix containing each word in the parsed string, where n is the number of words in the string. For example, the string <em>07 December 2016</em> has a word bank of size 1 x 3.</p>
<p>A proximity table is an m x n matrix which stores the distance of a word to every other word in the string. Each column i (ranging from 1 to n) corresponds to a word in the string. And each item j in column i (ranging from 1 to m) also corresponds to a word in the string. Therefore, the proximity table for <em>07 December 2016</em> is of size 3 x 3 and looks like the following:</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>07</strong></th>
<th><strong>December</strong></th>
<th><strong>2016</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>07</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td><strong>December</strong></td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>2016</strong></td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Using the word bank and the proximity table, DateRangeParser looks for all dates (i.e. just the 07 in <em>07 December 2016</em>) in the given string. For each date found, the algorithm looks for the nearest month and nearest year and uses this information to form a complete date.</p>
<p>The component returns a list of two dates â€” the start date and the end date in that order.</p>
<p>View the entire component <a href="https://gist.github.com/octos4murai/2317bdd4b977744ebbfd314bf1cb9830">here</a>.</p>

    </main>

    <footer>
        <p class="center-text no-margin no-padding"><a href="https://github.com/octos4murai/personal-site/blob/master/LICENSE">MIT License</a></p>
        <p class="center-text no-margin no-padding"><a href="https://github.com/octos4murai/personal-site">/octos4murai</a></p>
    </footer>
</body>
</html>
