<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>When is Tail Recursion Worth the Trouble? | Al Idian</title>

    <meta name="description" content="A personal site about software development">

    <link rel="preconnect" href="https://fonts.gstatic.com"> 
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&amp;family=Merriweather&amp;display=swap">

    <link rel="stylesheet" href="/css/syntax-highlight.css">
    <link rel="stylesheet" href="/css/style.css">

    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
</head>
<body>
    <header>
        <h3 id="site-title" class="no-margin no-padding"><a href="/">Al Idian</a></h3>
    </header>

    <main>
        
<h1 id="post-title">When is Tail Recursion Worth the Trouble?</h1>
<p id="post-date" class="gray-text">2017.07.05</p>

<h3>Recursion</h3>
<p>Simply put, recursive code is code that invokes itself within its execution. Well-written recursive code has at least two parts: (1) a recursive case and (2) a base case. As the name suggests, the recursive case contains the recursive step, i.e. it performs the self-invocation calling smaller and smaller versions of itself. This last detail is important because it ensures that the base case is eventually arrived at (otherwise a stack overflow <em>usually</em> occurs). At the base case, the final solution is found, and the function is exited.</p>
<p>A classic example of a recursive function:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="highlight-line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">FactorialRecursive</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> number<span class="token punctuation">)</span></span><br><span class="highlight-line"><span class="token punctuation">{</span></span><br><span class="highlight-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span></span><br><span class="highlight-line">    <span class="token punctuation">{</span></span><br><span class="highlight-line">        <span class="token comment">// Base case</span></span><br><span class="highlight-line">        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></span><br><span class="highlight-line">    <span class="token punctuation">}</span></span><br><span class="highlight-line">    <span class="token keyword">else</span></span><br><span class="highlight-line">    <span class="token punctuation">{</span></span><br><span class="highlight-line">        <span class="token comment">// Recursive case</span></span><br><mark class="highlight-line highlight-line-active">        <span class="token keyword">return</span> number <span class="token operator">*</span> <span class="token function">FactorialRecursive</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></mark><br><span class="highlight-line">    <span class="token punctuation">}</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialRecursive</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 6 by computing 3 x 2 x 1</span></span><br><span class="highlight-line">Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialRecursive</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 120 by computing 5 x 4 x 3 x 2 x 1</span></span><br><span class="highlight-line">Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialRecursive</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 1</span></span><br><span class="highlight-line">Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialRecursive</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 1</span></span></code></pre>
<p>This example is so common because it quickly demonstrates the main benefit of a recursive implementation: it can make code more intuitive and readable. In my experience, I find computer scientists tend to have a fondness for recursive implementations — perhaps because of its mathematical heritage. <em>Elegant</em> is a common word used to describe the appeal of well-written recursive code.</p>
<p>Alas, recursive implementations have a common problem!</p>
<p>Recursion relies on repeatedly invoking the same function. Whenever a function is invoked, a contiguous section of memory is allocated on the stack. Every time a function finishes executing, that section of memory is freed. By invoking functions within functions (within functions) such that none of them finish executing, the stack can fill up quickly, eventually resulting in a <em>stack overflow</em>.</p>
<p>Cue tail recursion…</p>
<h3>How Tail Recursion Can Help</h3>
<p>Tail recursion is a subset of recursion where the recursive call is simultaneously the final computational step.</p>
<p>In the function FactorialRecursive() above, we see in the highlighted line above that the recursive call <em>FactorialRecursive(number - 1)</em> is only the penultimate step. The final step is actually to multiply the result of that call with the value in variable <em>number</em>.</p>
<p>Here is a tail recursive version of the same function:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">FactorialTailRecursive</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> number<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> multiplier<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token comment">// Base case</span><br>        <span class="token keyword">return</span> multiplier<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">else</span><br>    <span class="token punctuation">{</span><br>        <span class="token comment">// Recursive case</span><br>        <span class="token keyword">return</span> <span class="token function">FactorialTailRecursive</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> number <span class="token operator">*</span> multiplier<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialTailRecursive</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 6 by computing 3 x 2 x 1</span><br>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialTailRecursive</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 120 by computing 5 x 4 x 3 x 2 x 1</span><br>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialTailRecursive</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 1</span><br>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">FactorialTailRecursive</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 1</span></code></pre>
<p>They key difference in this tail-recursive method is that our recursive call is also our final computational step. But what is it about tail recursion that makes it better than your regular flavour of recursion?</p>
<p>Well, many popular language compilers recognize this structure and are able to perform <em>tail-call optimization</em>.</p>
<p>Tail call optimization is a compiler feature by which a tail-recursive function can take no additional stack space beyond the initial function. This ability comes with the realization that any tail-recursive function A calling tail-recursive function B (in this instance B is the same function as A) needs only return whatever function B returns.</p>
<p>In this sense, the output derived in the final recursion is merely passed back up to the first function. Since no additional work is done between the recursive calls and their respective return statements, the compiler does not need to keep stack space for each method in the recursive process. That space can instead be reused for every recursive function call.</p>
<h3>When is Tail Recursion Worth the Trouble?</h3>
<p>Unfortunately, many compiler writers have decided not to support tail call optimization, in effect forcing their users to use an iterative implementation for anything that involves sufficiently deep recursion.</p>
<p>Simply put, know whether your language compiler supports tail call optimization. If it does (e.g. ES6, Scheme, Scala), recursive functions are a viable option. Otherwise (e.g. stock Python, Java, C#), stick with loops.</p>

    </main>

    <footer>
        <p class="center-text no-margin no-padding"><a href="https://github.com/octos4murai/personal-site/blob/master/LICENSE">MIT License</a></p>
        <p class="center-text no-margin no-padding"><a href="https://github.com/octos4murai/personal-site">/octos4murai</a></p>
    </footer>
</body>
</html>
